<!DOCTYPE html>
<!--[if IE]><![endif]-->
<html>
  
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge,chrome=1">
    <title>Marching Squares </title>
    <meta name="viewport" content="width=device-width">
    <meta name="title" content="Marching Squares ">
    <meta name="generator" content="docfx 2.59.0.0">
    
    <link rel="shortcut icon" href="../../favicon.ico">
    <link rel="stylesheet" href="../../styles/docfx.vendor.css">
    <link rel="stylesheet" href="../../styles/docfx.css">
    <link rel="stylesheet" href="../../styles/main.css">
    <link rel="stylesheet" href="../../styles/custom.css">
    <meta property="docfx:navrel" content="../../toc.html">
    <meta property="docfx:tocrel" content="../toc.html">
    
    
    
  </head>
  <body data-spy="scroll" data-target="#affix" data-offset="120">
    <div id="wrapper">
      <header>
        
        <nav id="autocollapse" class="navbar navbar-inverse ng-scope" role="navigation">
          <div class="container">
            <div class="navbar-header">
              <button type="button" class="navbar-toggle" data-toggle="collapse" data-target="#navbar">
                <span class="sr-only">Toggle navigation</span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
                <span class="icon-bar"></span>
              </button>
              
              <a class="navbar-brand" href="../../index.html">
                <img id="logo" class="svg" src="../../logo.svg" alt="">
              </a>
            </div>
            <div class="collapse navbar-collapse" id="navbar">
              <form class="navbar-form navbar-right" role="search" id="search">
                <div class="form-group">
                  <input type="text" class="form-control" id="search-query" placeholder="Search" autocomplete="off">
                </div>
              </form>
            </div>
          </div>
        </nav>
        
        <div class="subnav navbar navbar-default">
          <div class="container hide-when-search" id="breadcrumb">
            <ul class="breadcrumb">
              <li></li>
            </ul>
          </div>
        </div>
      </header>
      <div role="main" class="container body-content hide-when-search">
        
        <div class="sidenav hide-when-search">
          <a class="btn toc-toggle collapse" data-toggle="collapse" href="#sidetoggle" aria-expanded="false" aria-controls="sidetoggle">Show / Hide Table of Contents</a>
          <div class="sidetoggle collapse" id="sidetoggle">
            <div id="sidetoc"></div>
          </div>
        </div>
        <div class="article row grid-right">
          <div class="col-md-10">
            <article class="content wrap" id="_content" data-uid="">
<h1 id="marching-squares">Marching Squares</h1>

<p>Marching squares, sometimes also called corner Wang tiling, is a clever technique for autotiling a grid with tiles.</p>
<p>This technique is often used to <a href="https://www.boristhebrave.com/2018/04/15/marching-cubes-tutorial/">describe making an isosurface</a>, but in this tutorial, we'll focus more on a bitwise trick for selecting tiles. <a href="http://www.cr31.co.uk/stagecast/wang/2corn.html">Here's good tutorial for the general idea</a>.</p>
<p>We're going to have a square grid. Then store a boolean value on each <em>vertex</em> of the grid. Then we will pick a tile for each cell of a grid, based on the 4 boolean values, found at the corners of the squares.</p>
<p>// TODO: images</p>
<p>Because we want a single value per vertex, we need a key that uniquely identifies each vertex of the grid. This is where the <a href="../concepts/dual.html"><strong>dual grid</strong></a> comes in.</p>
<p>The dual grid is a grid with one cell per vertex in the base grid. Sylves comes with <a href="../concepts/dual.html#working-with-dual-grids">many methods</a> for working with this grid.</p>
<h2 id="setup">Setup</h2>
<p>We define the grids we use. I'm using a square grid for simplicity. Square grids are so simple, you'll notice the Sylves code is a bit more verbose than just doing all the calculations yourself. But in fact this code and tutorial is generic and will work with any grid in Sylves.</p>
<pre><code class="lang-csharp">// Make the grid we're going to fill with tiles
IGrid baseGrid = new SquareGrid(1, new SquareBound(new Vector2Int(0, 0), new Vector2Int(20, 10)));
// Get the dual - we'll need this for working with corners
IDualMapping dualMapping = baseGrid.GetDual();
IGrid dualGrid = dualMapping.DualGrid;
// In this case, dual grid will itself be a square grid, but offset from base grid, and with size one larger (21 by 11)
</code></pre>
<p><code>data</code> holds the actual values for each vertex. We'll decide what tile to use based on it.  As explained in the <a href="../concepts/storage.html">concepts</a>, Sylves doesn't come with any storage classes, you can use your own. We'll just use standard Dictionary.</p>
<pre><code class="lang-csharp">// Initialialize our storage data randomly, one value per base grid vertex, i.e. dual grid cell.
var random = new System.Random();
Dictionary&lt;Cell, bool&gt; data = dualGrid.GetCells()
    .ToDictionary(cell =&gt; cell, cell =&gt; random.NextDouble() &gt; 0.5 );
</code></pre>
<h2 id="getting-the-tile">Getting the tile</h2>
<p>Now we have our stored data, we want to compute which tile to put into each cell of the square grid. We'll use a well known bitwise trick. There are 4 corners to each square, and each has an independent boolean value. We can store the four booleans as 4 bits in an integer, and get a number between 0 and 15, which can be used to index an array containing our tiles.</p>
<img src="../../images/marching_squares_tiles.png">
<p>In Sylves, the corners are numbered counter clockwise, starting from DownRight.</p>
<pre><code class="lang-csharp">SquareCorner.DownRight = 0
SquareCorner.UpRight = 1
SquareCorner.UpLeft = 2
SquareCorner.DownLeft = 3
</code></pre>
<p>So we just need loop over the corners, find the corresponding value in <code>data</code>, and add that bit into the total. There's a method <a href="(xref:Sylves.DualMappingExtensions.DualNeighbours(Sylves.IDualMapping,Sylves.Cell))"><code>DualNeighbours</code></a> which will help with this.</p>
<pre><code class="lang-csharp">int GetTile(Cell baseCell)
{
    int tileIndex = 0;
    foreach(var tuple in dualMapping.DualNeighbours(baseCell))
    {
        CellCorner corner = tuple.corner;
        Cell dualCell = tuple.dualCell;
        // The bit this corner corresponds to
        var bit = 1 &lt;&lt; (int)corner;
        // If the vertex is true, include this bit
        if(data[dualCell])
        {
            tileIndex += bit;
        }
    }
    return tileIndex;
}
</code></pre>
<p>We can generate the full map simply by running this method on every baseCell (<code>baseGrid.GetCells()</code>).</p>
<img src="../../images/marching_squares_map.png">
<h2 id="extensions">Extensions</h2>
<h3 id="triangle-grids">Triangle grids</h3>
<p>It's popular to run marching squares on triangle grids. Because <a href="https://www.boristhebrave.com/2021/05/23/triangle-grids/">triangles have fewer corners</a> than square grids, there are fewer combinations of tiles. But you have to deal with up and down pointing triangles separately. Sylves uses a trick to make this easier for you. The corners of up and down triangles are assigned separate values:</p>
<pre><code class="lang-csharp">/// Values for CellCorner when working with FlatTopped triangles.
public enum FTTriangleCorner
{
    DownRight = 0,
    UpRight = 1,
    Up = 2,
    UpLeft = 3,
    DownLeft = 4,
    Down = 5,
}
</code></pre>
<p>Thus, when you call GetTile above, it'll give a different index for an up pointing triangle and a down pointing one. There are 2³ = 8 up indices and equally 8 down indices.</p>
<h3 id="3d-grids">3d grids</h3>
<p>Marching cubes is essentially the same algorithm as marching squares, just in 3d. There's 256 possible tile indices now. While dual grids do work a little different for 3d grids, the code above is all fully generic, and works just as well for 3d grids. Just swap out <code>SquareGrid</code> for <code>CubeGrid</code>, or any of <a href="../grids/index.html">Sylves' many other grids</a>.</p>
<h3 id="making-a-map-editor">Making a map editor</h3>
<p>If we wanted to let users edit cells, we just need change the corner value they clicked on, and reload nearby tiles. Some example code might look like the following:</p>
<pre><code class="lang-csharp">void OnUserClick(Vector3 position)
{
    // Find the vertex the user clicked on.
    if (dualGrid.FindCell(position, out var dualCell))
    {
        // Update data
        data[dualCell] = !data[dualCell];
        // Find all the nearby baseCells to regenerate
        foreach(var baseCell in dualMapping.BaseNeighbours(dualCell))
        {
            RegenTile(baseCell);
        }
    }
}
</code></pre>
<p>The <a href="paint.html">paint tutorial</a> includes a more detailed example of user interactivity.</p>
<h3 id="handling-rotation">Handling rotation</h3>
<p>In the above example, we provided 16 different tiles, one for each possible combination of corner values.</p>
<p>That's often a pain! In many cases, you want to provide fewer tiles, and automatically rotate them to fit. Done properly, you only need to actually make 6 different tiles. Most implementations omit this, as it's a bit of a pain, but Sylves has <a href="../concepts/rotation.html">APIs for rotation</a> that will make it much easier.</p>
<p>We'll build a table that for each tile index, returns a smaller tile index and appropriate rotation that can be used as a substitue. For square tiles, you could just hard code this, but again, here's the generic code in Sylves.</p>
<pre><code class="lang-csharp">// Used to describe what other index and rotation to use
class TileAndRotation
{
    public int tileIndex;
    public CellRotation rotation;
}


// Setup
var cellType = SquareCellType.Instance;
var tileIndexCount = (int)Math.Pow(2, cellType.GetCellCorners().Count()); // 16 for squares
var rotationTable = new TileAndRotation[tileIndexCount];

// Some utility methods, using the bitwise trick
IList&lt;CellCorner&gt; FromTileIndex(int tileIndex)
{
    var result = new List&lt;CellCorner&gt;();
    foreach(var cellCorner in cellType.GetCellCorners())
    {
        if ((tileIndex &amp; (1 &lt;&lt; (int)cellCorner)) &gt; 0)
        {
            result.Add(cellCorner);
        }
    }
    return result;
}

int ToTileIndex(IEnumerable&lt;CellCorner&gt; corners)
{
    int tileIndex = 0;
    foreach(var corner in corners)
    {
        tileIndex += (1 &lt;&lt; (int)corner);
    }
    return tileIndex;
}

// For each tile index, see if we can find something else it can rotate from
for(var tileIndex = 0; tileIndex &lt; tileIndexCount; tileIndex++)
{
    var corners = FromTileIndex(tileIndex);
    TileAndRotation best = null;
    // Try each rotation
    foreach (var rotation in cellType.GetRotations(includeReflections: false))
    {
        // Rotate all the corners by rotation
        var rotatedCorners = corners.Select(corner =&gt; cellType.Rotate(corner, rotation));
        var rotatedIndex = ToTileIndex(rotatedCorners);
        // Is this a better choice?
        if(rotatedIndex &lt; tileIndex &amp;&amp; (best == null || rotatedIndex &lt; best.tileIndex))
        {
            best = new TileAndRotation {tileIndex = rotatedIndex, rotation = cellType.Invert(rotation)};
        }
    }
    rotationTable[tileIndex] = best;
}
</code></pre>
<p>Afterwards, rotation table will be filled like:</p>
<table>
<thead>
<tr>
<th>tileIndex</th>
<th>fromTileIndex</th>
<th>rotation</th>
</tr>
</thead>
<tbody>
<tr>
<td>0</td>
<td></td>
<td></td>
</tr>
<tr>
<td>1</td>
<td></td>
<td></td>
</tr>
<tr>
<td>2</td>
<td>1</td>
<td>1</td>
</tr>
<tr>
<td>3</td>
<td></td>
<td></td>
</tr>
<tr>
<td>4</td>
<td>1</td>
<td>2</td>
</tr>
<tr>
<td>5</td>
<td></td>
<td></td>
</tr>
<tr>
<td>6</td>
<td>3</td>
<td>1</td>
</tr>
<tr>
<td>7</td>
<td></td>
<td></td>
</tr>
<tr>
<td>8</td>
<td>1</td>
<td>3</td>
</tr>
<tr>
<td>9</td>
<td>3</td>
<td>3</td>
</tr>
<tr>
<td>10</td>
<td>5</td>
<td>3</td>
</tr>
<tr>
<td>11</td>
<td>7</td>
<td>3</td>
</tr>
<tr>
<td>12</td>
<td>3</td>
<td>2</td>
</tr>
<tr>
<td>13</td>
<td>7</td>
<td>2</td>
</tr>
<tr>
<td>14</td>
<td>7</td>
<td>1</td>
</tr>
<tr>
<td>15</td>
<td></td>
<td></td>
</tr>
</tbody>
</table>
<p>i.e. indicating that tileIndex 14 is the same as tileIndex 7, but rotated by <code>(SquareRotation)2</code>, i.e. 180 degrees. You only need tile indices 0, 1, 3, 5, 7 and 15 to make a complete set.</p>
</article>
          </div>
          
          <div class="hidden-sm col-md-2" role="complementary">
            <div class="sideaffix">
              <div class="contribution">
                <ul class="nav">
                </ul>
              </div>
              <nav class="bs-docs-sidebar hidden-print hidden-xs hidden-sm affix" id="affix">
                <h5>In This Article</h5>
                <div></div>
              </nav>
            </div>
          </div>
        </div>
      </div>
      
      <footer>
        <div class="grad-bottom"></div>
        <div class="footer">
          <div class="container">
            <span class="pull-right">
              <a href="#top">Back to top</a>
            </span>
            
            <span>Generated by <strong>DocFX</strong></span>
          </div>
        </div>
      </footer>
    </div>
    <script type="text/javascript" src="../../styles/docfx.vendor.js"></script>
    <script type="text/javascript" src="../../styles/docfx.js"></script>
    <script type="text/javascript" src="../../styles/main.js"></script>
  </body>
</html>
